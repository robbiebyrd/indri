package game

import (
	"fmt"
	"github.com/kpechenenko/rword"
	"github.com/robbiebyrd/indri/internal/models"
	"github.com/robbiebyrd/indri/internal/repo/game"
	"log"
	"strings"
)

type Service struct {
	gameRepo *game.Repo
	Script   *models.Script
}

var globalClient *Service

// NewService creates a new repository for accessing game data.
func NewService(gameRepo *game.Repo, script *models.Script) *Service {
	if gameRepo == nil {
		gameRepo = game.NewRepo()
	}

	if globalClient == nil {
		globalClient = &Service{
			gameRepo: gameRepo,
			Script:   script,
		}
	}

	return globalClient
}

// New creates a new game, with or without a Code.
func (gs *Service) New(gameCode string) (*models.Game, error) {
	if gameCode == "" {
		// If no gameCode was given, then we will try to create a random one
		autogenCode, err := gs.getAutoGeneratedGameCode()
		if err != nil {
			return nil, err
		}

		gameCode = autogenCode
	}

	if gs.Exists(gameCode) {
		return nil, fmt.Errorf("game with id %s already exists", gameCode)
	}

	log.Printf("creating new game with gameCode %v ", gameCode)

	g, err := gs.gameRepo.New(gameCode, gs.Script)
	if err != nil {
		return nil, err
	}

	return g, nil
}

// Get will fetch game data for a specific game ID  or create a new one if it doesn't exist.
func (gs *Service) Get(id string) (*models.Game, error) {
	g, err := gs.gameRepo.Get(id)
	if err != nil {
		return gs.New(id)
	}

	return g, nil
}

// GetByCode will fetch game data for a specific game code or create a new one if it doesn't exist.
func (gs *Service) GetByCode(gameCode string) (*models.Game, error) {
	if gameCode == "" {
		return nil, fmt.Errorf("game code is empty")
	}

	gameId, err := gs.gameRepo.GetIDHex(gameCode)
	if err != nil {
		return gs.New(gameCode)
	}

	g, err := gs.gameRepo.Get(*gameId)
	if err != nil {
		return nil, err
	}

	return g, nil
}

// Fetch retrieves game data for a specific game ID  and returns an error if not found.
func (gs *Service) Fetch(id string) (*models.Game, error) {
	if id == "" {
		return nil, fmt.Errorf("id is  nil")
	}

	return gs.gameRepo.Get(id)
}

// FetchByCode retrieves game data for a specific game code  and returns an error if not found.
func (gs *Service) FetchByCode(gameCode string) (*models.Game, error) {
	if gameCode == "" {
		return nil, fmt.Errorf("game code is required")
	}

	gameId, err := gs.gameRepo.GetIDHex(gameCode)
	if err != nil {
		return nil, err
	}

	return gs.gameRepo.Get(*gameId)
}

// Exists checks to see if a game with the given ID already exists.
func (gs *Service) Exists(id string) bool {
	if id == "" {
		return false
	}

	exists, err := gs.gameRepo.Exists(id)
	if err != nil {
		return false
	}

	return exists
}

// Update saves game data to the repository.
func (gs *Service) Update(id string, game *models.UpdateGame) error {
	if id == "" {
		return fmt.Errorf("game code cannot be empty")
	}

	err := gs.gameRepo.Update(id, game)
	if err != nil {
		return err
	}

	return nil
}

// Reset a game to its defaults.
func (gs *Service) Reset() *models.Game {
	// TODO: reload a game from a script
	return nil
}

// Sanitize removes private items.
func (gs *Service) Sanitize(game *models.Game) *models.Game {
	game.Stage.PrivateData = nil

	for i, g := range game.Stage.Scenes {
		g.PrivateData = nil
		game.Stage.Scenes[i] = g
	}

	for i, t := range game.Teams {
		t.PrivateData = nil
		game.Teams[i] = t
	}

	for i, p := range game.Players {
		p.PrivateData = nil
		game.Players[i] = p
	}

	return game
}

func (gs *Service) ConnectPlayer(id string, teamId string, userId string) error {
	switch {
	case gs.gameRepo.HasPlayerOnTeam(id, teamId, userId):
		log.Printf("Player %v is on team %v\n", userId, teamId)
		return gs.gameRepo.ConnectPlayer(id, userId)
	case gs.gameRepo.PlayerOnATeam(id, userId):
		log.Printf("Player %v is already on a team, changing\n", userId)
		return gs.gameRepo.ChangePlayerTeam(id, teamId, userId)
	case teamId != "":
		log.Printf("Adding player %v to team %v\n", userId, teamId)
		return gs.gameRepo.AddPlayerToTeam(id, teamId, userId)
	default:
		log.Printf("Adding player %v to game lobby\n", userId)
		return gs.gameRepo.AddPlayer(id, userId)
	}
}

func (gs *Service) DisconnectPlayer(id string, userId string) error {
	if gs.gameRepo.HasPlayer(id, userId) {
		return gs.gameRepo.DisconnectPlayer(id, userId)
	}

	return nil
}

func (gs *Service) RemovePlayer(id string, userId string) error {
	return gs.gameRepo.RemovePlayer(id, userId)
}

func (gs *Service) getAutoGeneratedGameCode() (string, error) {
	autogenCode, _ := gs.makeRandomGameId()
	for exists, _ := gs.gameRepo.Exists(autogenCode); exists; {
		autogenCode, _ = gs.makeRandomGameId()
	}

	return autogenCode, nil
}

func (gs *Service) makeRandomGameId() (string, error) {
	rw, err := rword.New()
	if err != nil {
		return "", err
	}

	id := strings.ReplaceAll(rw.Str(4)+rw.Str(4)+rw.Str(4), " ", "-")

	return id, nil
}
