package game

import (
	"fmt"
	"github.com/kpechenenko/rword"
	"github.com/robbiebyrd/indri/internal/models"
	"github.com/robbiebyrd/indri/internal/repo/game"
	"log"
	"strings"
)

type Service struct {
	gameRepo *game.Repo
}

var gameService *Service

// NewService creates a new repository for accessing game data.
func NewService() *Service {
	if gameService == nil {
		gameService = &Service{
			gameRepo: game.NewRepo(),
		}
	}

	return gameService
}

// Sanitize removes private items.
func (gs *Service) Sanitize(game *models.Game) *models.Game {
	game.Stage.PrivateData = nil

	for i, g := range game.Stage.Scenes {
		g.PrivateData = nil
		game.Stage.Scenes[i] = g
	}

	for i, t := range game.Teams {
		for j, p := range t.Players {
			p.PrivateData = nil
			t.Players[j] = p
		}

		game.Teams[i] = t
	}

	return game
}

// Get will fetch game data for a specific game ID, or create a new one if it doesn't exist.
func (gs *Service) Get(id string) (*models.Game, error) {
	g, err := gs.gameRepo.Get(id)
	if err != nil {
		return gs.New(id)
	}

	return g, nil
}

// GetByCode will fetch game data for a specific game code, or create a new one if it doesn't exist.
func (gs *Service) GetByCode(gameCode string) (*models.Game, error) {
	if gameCode == "" {
		return nil, fmt.Errorf("game code is empty")
	}

	gameId, err := gs.gameRepo.GetCode(gameCode)
	if err != nil {
		return nil, err
	}

	g, err := gs.gameRepo.Get(*gameId)
	if err != nil {
		return gs.New(*gameId)
	}

	return g, nil
}

// Fetch retrieves game data for a specific game ID, and returns an error if not found.
func (gs *Service) Fetch(id string) (*models.Game, error) {
	if id == "" {
		return nil, fmt.Errorf("id is  nil")
	}

	return gs.gameRepo.Get(id)
}

// FetchByCode retrieves game data for a specific game code, and returns an error if not found.
func (gs *Service) FetchByCode(gameCode string) (*models.Game, error) {
	if gameCode == "" {
		return nil, fmt.Errorf("game code is required")
	}

	gameId, err := gs.gameRepo.GetCode(gameCode)
	if err != nil {
		return nil, err
	}

	return gs.gameRepo.Get(*gameId)
}

// Exists checks to see if a game with the given ID already exists.
func (gs *Service) Exists(id string) bool {
	if id == "" {
		return false
	}

	exists, err := gs.gameRepo.Exists(id)
	if err != nil {
		return false
	}

	return exists
}

// Update saves game data to the repository.
func (gs *Service) Update(id string, game *models.UpdateGame) error {
	if id == "" {
		return fmt.Errorf("game code cannot be empty")
	}

	err := gs.gameRepo.Update(id, game)
	if err != nil {
		return err
	}

	return nil
}

// New creates a new game, with or without a Code.
func (gs *Service) New(gameCode string) (*models.Game, error) {
	if gameCode == "" {
		// If no gameCode was given, then we will try to create a random one
		autogenCode, err := gs.getAutoGeneratedGameCode()
		if err != nil {
			return nil, err
		}

		gameCode = autogenCode
	}

	if gs.Exists(gameCode) {
		return nil, fmt.Errorf("game with id %s already exists", gameCode)
	}

	log.Printf("creating new game with gameCode %v ", gameCode)

	g, err := gs.gameRepo.New(models.CreateGame{Code: gameCode})
	if err != nil {
		return nil, err
	}

	return g, nil
}

// Reset a game to its defaults.
func (gs *Service) Reset() *models.Game {
	// TODO: reload a game from a script
	return nil
}

func (gs *Service) getAutoGeneratedGameCode() (string, error) {
	autogenCode, _ := gs.makeRandomGameId()
	for exists, _ := gs.gameRepo.Exists(autogenCode); exists; {
		autogenCode, _ = gs.makeRandomGameId()
	}

	return autogenCode, nil
}

func (gs *Service) makeRandomGameId() (string, error) {
	rw, err := rword.New()
	if err != nil {
		return "", err
	}

	id := strings.ReplaceAll(rw.Str(4)+rw.Str(4)+rw.Str(4), " ", "-")

	return id, nil
}
